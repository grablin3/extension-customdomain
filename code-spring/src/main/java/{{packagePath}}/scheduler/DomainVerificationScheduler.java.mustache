package {{packageName}}.scheduler;

import {{packageName}}.jpa.entity.CustomDomainEntity;
import {{packageName}}.jpa.repository.CustomDomainRepository;
import {{packageName}}.model.enumtype.DomainStatus;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.annotation.Profile;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;

import java.time.Instant;
import java.util.List;

/**
 * Scheduled tasks for domain verification and cleanup.
 */
@Component
@Profile("customdomain")
public class DomainVerificationScheduler {

    private static final Logger log = LoggerFactory.getLogger(DomainVerificationScheduler.class);

    private final CustomDomainRepository domainRepository;

    public DomainVerificationScheduler(CustomDomainRepository domainRepository) {
        this.domainRepository = domainRepository;
    }

    /**
     * Mark expired verifications as failed.
     * Runs every hour.
     */
    @Scheduled(fixedRate = 3600000)  // Every hour
    @Transactional
    public void markExpiredVerifications() {
        List<CustomDomainEntity> expired = domainRepository.findExpiredVerifications(
            DomainStatus.PENDING_VERIFICATION,
            Instant.now()
        );

        for (CustomDomainEntity domain : expired) {
            domain.setStatus(DomainStatus.VERIFICATION_FAILED);
            domainRepository.save(domain);
            log.info("Marked domain verification as expired: {}", domain.getDomain());
        }

        if (!expired.isEmpty()) {
            log.info("Marked {} domains as verification expired", expired.size());
        }
    }

    /**
     * Clean up domains that have been in failed state for more than 30 days.
     * Runs daily at 3 AM.
     */
    @Scheduled(cron = "0 0 3 * * *")
    @Transactional
    public void cleanupFailedDomains() {
        // Find domains that failed verification more than 30 days ago
        Instant threshold = Instant.now().minusSeconds(30 * 24 * 60 * 60);

        List<CustomDomainEntity> failedDomains = domainRepository
            .findByTeamIdAndStatus(null, DomainStatus.VERIFICATION_FAILED);

        int cleaned = 0;
        for (CustomDomainEntity domain : failedDomains) {
            if (domain.getUpdatedAt().isBefore(threshold)) {
                domainRepository.delete(domain);
                cleaned++;
                log.info("Cleaned up failed domain: {}", domain.getDomain());
            }
        }

        if (cleaned > 0) {
            log.info("Cleaned up {} failed domains older than 30 days", cleaned);
        }
    }

    /**
     * Log domain statistics.
     * Runs daily at midnight.
     */
    @Scheduled(cron = "0 0 0 * * *")
    @Transactional(readOnly = true)
    public void logDomainStats() {
        long total = domainRepository.count();
        long active = domainRepository.findBySslStatus(
            {{packageName}}.model.enumtype.SslStatus.ACTIVE
        ).size();
        long pending = domainRepository.findBySslStatus(
            {{packageName}}.model.enumtype.SslStatus.PROVISIONING
        ).size();

        log.info("Domain stats - Total: {}, Active: {}, Pending SSL: {}", total, active, pending);
    }
}
